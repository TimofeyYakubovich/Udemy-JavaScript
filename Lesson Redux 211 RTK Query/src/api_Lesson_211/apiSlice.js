import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
// Lesson 211 Redux Toolkit RTK Query

// RTK Query позволяет удобно монипултровать запросами на сревер и кешировать данные

// задачи при работе с запросами
// 1 отображение индикаторов загрузки и ошибки
// 2 обнавление интерфейса 
// 3 связывание логики запросов с нашим интефейсом
// 4 актуализация данных сервера и тд.
// все эти задачи решает функционал RTK Query

// уже есть бибилотеки вдряющие все это и RTK Query вдохновлялся ими например react-query

// используя эти инструменты надо думать не имзенениями глобальных состояний а оперированием загруженными данными

// почти все действия в приложениях это разного рода запрсы на сервер 
// сейчас героев мы загружаем это метод GET создаем и отправляем на сервер метод POST удаляем героя DELETE если бы надо было обновить данные 
// у героя по id это метод PATCH
// даже если делать какие то расчеты например онлайн канкулятор чего то то данные всеравно получаем с сервера обрабатываем в какой то формуле 
// и отправляем в интерфейс и в интерфейсе на основании данных от пользователя что то выщитывается 
// или эти данные вообще статичны и просто живут внутри одного или нескольких компанентов
// тогда вопрос зачем вообще глобальный стейт? 

// сейчас в этом приложении при созаднии или удалени героя сначало идет запрос на сервер а потом изменятеся глобальный стейт
// можно избавиться от глобольного стейта и манипулировать только запросами

// реализуем такой функционал RTK Query он содержит в себе 2 главне функции createApi и fetchBaseQuery
// createApi обязательная функция каторая описывает все поведение RTK Query
// fetchBaseQuery модифицированный fetch

// этот файл apiSlice будет работать с запросами
// импортируем import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react' импортируются они из кусочка query тулкита их вытаскиваем
// и в react подхватится index.js там есть еще версия каторая не относится к реакту 

// создадим функционал каторый будет общаться с сервером и сразу проводить различные операции
// сйчас мы сделали один общий файл apiSlice сюда будут включаться все запросы но его можно и разделить на разные api например для героев и фильтров

// сейчас мы создаем срез каторый будет включаться в стор
// 1 настройка createApi будет reducerPath в каторой надо указать строку 'api' название редьюсера все данные будут помещены в store.api
// этот параметр можно и не задавать тогда автоматически будет подставлена эта строка 'api'

// следующее поле baseQuery обязательное это метод каторый будет делать запрос можно было бы использовать обычный fetch 
// но мы будем использоваь fetchBaseQuery она имеет готовые настройки внутри себя
// обезательная настройка в fetchBaseQuery это baseUrl куда идет запрос поумолчанию http://localhost:3001 локальный сервер

// следующее поле endpoints это метод каторый будет проводить операции по базовому адресу GET POST DELETE PATCH
// тут будет 2 типа действий 1 Query запрсы каторые получают данные и сохраняют их 2 mutation запрсы на измение данных на сервере
// endpoints принимает в себя функцию каторая как автоматический аргумент принимает в себя builder объект для конструирования
// этф функция должна вернуть объект в этом объекте надо описать нужные действия (Endpoint конечные точки)
// создадим действие Endpoint по получению героев getHeroes в нем так как мы просто запрашиваем данные используем метод query объекта builder
// builder.query в методе builder.query надо уазать куда обращаться что бы получить героев для этого в него передаем еще объект с свойством query
// и в нем будет функция каторая возвращает кусок строки '/heroes' куда делать запрос

// createApi автоматически генерирует реакт хуки на каждое действие Endpoint
// важно как формируется название этого хука сначала приставка use так как пользовательский хук потом название андпоинта getHeroes с большой буквы
// и в конце к названию хука присоединяется тпи андпоинта либо мутация либо запрос 
// как итог получается useGetHeroesQuery каторые мы сразу экспортируем и диструктурируем из объекта apiSlice

// createApi так же сразу создает редьюсер как и createSlice каторый надо передать в стор и в стейте он формирует свойство 'api'
export const apiSlice = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({baseUrl: 'http://localhost:3001'}),
    tagTypes: ['Heroes'], // связи между эндпоинтами при помщи тегов в массив строкми прописывается какие теги есть в это api
    // так как нет глобального стейта механизм что бы после каждого запроса на мутацию сразу же уходил запрос и на получение актуальных данных
    endpoints: builder => ({
        getHeroes: builder.query({
            query: () => '/heroes',
            providesTags: ['Heroes'] // если мы запрашиваем данные то эти данные относятся к тегу Heroes
        }),
        createHero: builder.mutation({ // mutation потому что проводим изменения на сервере
            query: hero => ({ // принимает аргумент hero
                url: '/heroes', // где проводим мутацию
                method: 'POST',
                body: hero  // hero будет автоматически переведен в json формат
            }),
            invalidatesTags: ['Heroes'] // тег указывает если происходит мутация то в каких данных это происходит
            // что именно загрузить по тегу повторно когда данные на сервере изменились
        }),
        deleteHero: builder.mutation({
            query: id => ({
                url: `/heroes/${id}`,
                method: 'DELETE'
            }),
            invalidatesTags: ['Heroes']
        })
    })
})

export const {useGetHeroesQuery, useCreateHeroMutation, useDeleteHeroMutation} = apiSlice;